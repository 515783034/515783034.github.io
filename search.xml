<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一次 Cocoa App(macOS App)开发尝试]]></title>
    <url>%2F2019%2F03%2F01%2Ftry-macos-app%2F</url>
    <content type="text"><![CDATA[“我们从小就听长辈们说起过懒汉，仿佛懒惰很不体面。实际上，没有我们的这些懒汉，恐怕就没有社会的进步；没有我们的这些懒汉，勤劳的人面对的恐怕只会是单调乏味的劳作。”这里引入小学课本学过的文章《懒惰的智慧》中的一句话，深以为这句话就是对我们程序员群体的真实写照，促进社会进步说的有点夸张，但是提高生产效率还是不在话下的，这也是我本次纪录的一点儿动力。 好好的开发 iOS，为什么要玩玩 macOS 呢？自我揣测每一位 iOSer 的内心中都有一个开发 macOS 的冲动，毕竟工具(mac + Xcode)和基础技术(Objective-C, Swift)都是现成的，iOS 开发的应用需要上架才能使用，而 mac App 甚至都可以省略上架这一步，在朋友间传播起来也方便得多。 闲话少说，今天谈谈最近一次开发的 macOS App 开发者之刃 App Store、开发者之刃 首页。 功能包括： 色盘(存储配色方案) 图标生成器（生成 iOS/macOS/Android 多尺寸图标文件） 图像压缩（基于 TinyPng） json 转模型(json 字符串转成 swift 模型对象) 开源库集（github 开源库分类整理）等功能 支持开机自启动、全局快捷键、自动检查更新等。 1. 从技术的角度谈谈做了什么1.1 开发了一款 macOS App主要采用 Swift4.2 编写“开发者之刃”，相比于 OC，Swift 的优势想必用过的朋友们都知道。 “开发者之刃”的技术点大概如下： CocoaPods管理第三方开源库 Alamofire 网络框架 CocoaLumberjack/Swift 日志纪录 SnapKit 自动布局 Kingfisher 网络图片加载缓存 Fabric bug 及用户行为分析 LaunchAtLogin 开机自启动 全局快捷键：主要用到 RegisterEventHotKey方法 Python 和 Swift 交互：可以看下之前写的文章《我用 Xcode+python 写的第一个 OSX app》，关键词：Process 本地缓存：未使用数据库，采用 json 格式存本地文件，使用的库：ObjectMapper 对于没有开发mac 经验的同学，推荐剑指人心的 《macOS 应用开发基础教程》，入门是完完全全没有问题的。“开发者之刃”里面用到的技术基本上都能在这本书中找到，而且从完全没有 mac App 开发经验到上架一个完整的 App，本人是照着书中内容一步步走下来的，这里也一并感谢下作者。 1.2 顺手撸了个服务端采用 Python 的 Flask 库搭建的服务端，操作简单，功能全面。IDE 用的是 PyCharm。 这里为什么要用“顺手”二字呢？实实在在是没有服务端的开发经验，在网易云课堂上看了一个教程，操起键盘就是干。中间遇到问题就 Google 一下，不能解决的就直接绕过去了，所以到最后功能既不完善，也不系统，但也勉强够用。毕竟精力有限，以完善功能为主，系统性的学习还任重而道远。 服务端的技术点大概如下： pip: 包管理工具 Flask: Web 开发微框架 SQLAlchemy: 数据库工具 Flask-Migrate: 数据库升级工具 http 请求、web 页面：Flask 很容易实现 Vue: 渐进式 JavaScript 框架，快速构建 web 页面 半吊子都算不上的服务端开发，这里就不班门弄斧了，基本功能大概如上所诉。照着网易云上的视频 Python Flask系列（1）——基础 学习的 Flask 基础，感觉讲的挺好，浅显易懂，写个简简单单的页面是完全足够了。 1.3 切了几张图图可以切，审美就不不必较真了。 技术呢也没有用到什么技术(主要是我都不知道有啥技术，完全两眼一抹黑)，这里就简单介绍下用的工具吧。 Sketch：轻量易用的矢量设计工具。易用易用，谁用谁知道。 iconfont:矢量图标管理、交流平台。免费图标多种多样，可下载源文件，也可指定颜色、大小下载。 tinypng: 智能有损压缩图片。“开发者之刃”中的图片压缩功能核心就是用的它的服务，压缩率高，压缩后的图像几乎肉眼看不到失真。 2. 谈谈为什么要做这个 App前面提到了，每个 iOSer 的内心中都有一颗开发 mac App 的心，其实说白了，每一个程序员的内心中都有尝试新事物的冲动。 确确实实解决开发中的一些痛点。服务端甩给客户端一大串 json，我们每次构建对象时烦不胜烦，机械重复的代码只是在浪费我们有限的生命与激情，所以有了《json 转模型》的想法。设计给的色值一天三变，背景色、基础字体颜色不统一，被他们一句“这个颜色就是之前用的”弄得痛不欲生，自己设计个玩意后，色值转身就忘，所以有了《色盘》的想法。github 看到优秀的仓库也不太想 star，实在是 star 的数量过多，想用的时候像是大海捞针，所以有了《开源库集》的想法。自己写个 App，要被切各个尺寸的图弄疯，切完还得一张张拖到 Assets 中合适的坑中，总之开发中总会遇到一些重复的工作，大概是可以通过代码处理的吧。 学习真的会使人快乐。当刚开始接触一个新的技术时，汲取知识的快感是强烈的，不论是纯粹的学习还是单纯想炫技，能学到东西总归是一个非常好的结果。当然要深挖技术时的确会有痛苦，痛并快乐着吧。 3. 作一个简单的总结技术： mac App 开发：Swift + Xcode web 开发：Python + PyCharm 切图：iconfont + Sketch 资源： 开发者之刃 首页 《macOS 应用开发基础教程》 Python Flask系列（1）——基础 iconfont tinypng]]></content>
      <categories>
        <category>macos</category>
      </categories>
      <tags>
        <tag>macos</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自建 iOS 静态库并用 pod 管理]]></title>
    <url>%2F2018%2F03%2F20%2F%E8%87%AA%E5%BB%BA%20iOS%20%E9%9D%99%E6%80%81%E5%BA%93%E5%B9%B6%E7%94%A8%20pod%20%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[序言本文将主要讨论如下几个问题： OC 和 Swift 混编的形式创建支持多种架构的静态库（.framework）； 静态库引用其他静态库（.framework 或 .a)； 静态库添加资源文件； pod 管理静态库。 创建静态库 framework最近公司由于和其他公司建立了各种合作关系，“创建 SDK”工作被提上了日程，由于之前没有自己做过，在生成 framework 时踩了一些坑，在这里记录下来以做总结，若码友能用得上则不胜开心。工作中难免会遇到这种情况，想把某个功能包装起来给其他人用，但是出于某种原因又不想公开自己的实现方式，这时就需要静态库（framework 或 .a）了。(PS：.a 和 .framework 的区别可以看下这篇文章：iOS开发-.a与.framework区别？ 创建静态库1XCode -&gt; File -&gt; New -&gt; Project -&gt; Cocoa Touch Framework 创建 SJTutorialSDK，并新建测试类名为 HelloWorld（Swift）、HelloOC(OC)，目录如下： 1234567891011121314151617├── SJTutorialSDK│ ├── HelloOC.h -&gt; 暴露的 OC 类│ ├── HelloOC.m│ ├── HelloWorld.swift -&gt; 暴露的 Swift 类│ ├── Info.plist│ └── SJTutorialSDK.h -&gt; 当前静态库头文件└── SJTutorialSDK.xcodeproj ├── project.pbxproj ├── project.xcworkspace │ ├── contents.xcworkspacedata │ └── xcuserdata │ └── shijian.xcuserdatad │ └── UserInterfaceState.xcuserstate └── xcuserdata └── shijian.xcuserdatad └── xcschemes └── xcschememanagement.plist 对于 Swift，对外暴露的文件需要用 public（或 open）修饰，并且要继承自 NSObject(或其子类)； 对于 OC，对外暴露的文件需要在“Build Phases -&gt; Headers -&gt; Public”添加相应头文件（例：HelloOC.h），并在 framework 的头文件（例：SJTutorialSDK.h）中添加对该头文件的引用(例：#import &lt;SJTutorialSDK/HelloOC.h&gt;)； 如果当前 framework 引用了第三方 framework，需要在头文件（例：SJTutorialSDK.h）中添加对第三方头文件的引用（例：#import &lt;SJDemoSDK/Animals.h&gt;)。 创建完成后的头文件如下： 123456789101112// SJTutorialSDK.h// SJTutorialSDK#import &lt;UIKit/UIKit.h&gt;FOUNDATION_EXPORT double SJTutorialSDKVersionNumber;FOUNDATION_EXPORT const unsigned char SJTutorialSDKVersionString[];// 第三方库的头文件#import &lt;SJDemoSDK/Animals.h&gt;// 对外暴露的头文件（仅限于 OC，Swift 添加 public 后会自动导入）#import &lt;SJTutorialSDK/HelloOC.h&gt; Build Phases 配置如下： 至此，静态库.framework 创建完毕。 支持多种架构我们开发过程中经常提到的 arm64，x86_64 具体是什么东西呢？这里可以参考这篇文章: iOS 中的 armv7,armv7s,arm64,i386,x86_64 都是什么。 简单点来说：模拟器 32/64 位处理器分别需要 i386/x86_64 架构，真机 32/64 位处理器分别需要 armv7(armv7s)/arm64 架构。所以，如果你构建的静态库只需要支持 iPhone 5S 及以上(或 iPad mini2 及以上)的真机和模拟器，那么你的静态库将只需支持 arm64 和 x86_64 架构。 调整到 Release(发布)模式：Edit Scheme -&gt; Run -&gt; Info -&gt; Build Configuration -&gt; Release； 分别使用真机、模拟器编译，生成对应的 SJTutorialSDK.framework； 合并 frameworks 1234567# 查看静态库支持的架构lipo -info xxx# 合并 xxx1 和 xxx2，最后的文件支持两者支持的所有架构lipo -create xxx1 xxx2 -output xxx1eg:lipo -creat Release-iphoneos/SJTutorialSDK.framework/SJTutorialSDK Release-iphonesimulator/SJTutorialSDK.framework/SJTutorialSDK -output Release-iphoneos/SJTutorialSDK.framework/SJTutorialSDK 生成 framework 时踩过的坑：-output 的文件是 xxx，而不是 xxx.framework 查看最后的静态库支持架构: 12Architectures in the fat file: /Users/shijian/Desktop/SJTutorialSDK.framework/SJTutorialSDK are: x86_64 arm64# congratulations 添加资源文件在 iOS 中，可以通过 Bundle 文件管理资源文件(图片，语音，视频，plist，xib，storyboard等)，Bundle 文件实际上就是个普通的文件夹，只是在名字中添加了 .Bundle 的后缀而已。对图片的命名最好添加上 @3x/@2x，这样系统会自动放在对应的位置，不需要我们额外的操作。 新建文件夹 xxx，并添加相应资源，然后更名为 xxx.Bundle，也可以直接新建 xxx.Bundle，鼠标右键 -&gt; 显示包内容 -&gt; 添加相应文件； 1234.└── SJTutorialRes.Bundle ├── alipay@3x.png └── wechat@3x.png 新建方法读取 Bundle 中的图片 12345678910111213141516171819import UIKit// public 以使外界能够访问public class TutorialRes: NSObject &#123; public static func getImg(_ name: String) -&gt; UIImage? &#123; guard let url = Bundle(for: TutorialRes.self).url(forResource: "SJTutorialRes", withExtension: "Bundle") else &#123; return nil &#125; guard let path = Bundle(url: url)?.path(forResource: name, ofType: nil) else &#123; return nil &#125; return UIImage(contentsOfFile: path) &#125; public static func aliImg() -&gt; UIImage? &#123; return getImg("alipay@3x.png") &#125; public static func WechatImg() -&gt; UIImage? &#123; return getImg("wechat@3x.png") &#125; &#125; 至此，静态库已经创建完毕，当前创建的静态库 SJTutorialSDK 有如下特性：支持 OC 和 Swift 混编，引用了其他第三方库，支持资源文件读取，支持多种架构。 pod 管理静态库如果自己的静态库是私有的，可以跳过 trunk 环节，直接在自己的代码仓库中创建好仓库，然后配置相应的 podspec 文件，pod 引用时指定对应的路径即可。但大多数情况下还是要给其他人使用的，我们当然也可以不通过 trunk，直接在引用时指定地址来使用当前仓库，但是这样用起来总是不那么直观。 1234# 通过名称和指定地址使用pod 'SJTutorialSDK',:git =&gt; "git@code.XXX/SJTutorialSDK.git"# 通过名称pod 'SJTutorialSDK' 两者对比起来，高下立判。所以建议还是通过 trunk 来 push 自己的代码。 配置 podspec 文件如何在 github 上新建仓库，网上已经有很多的教程，这里不再赘述，这里主要谈谈配置 podspec 文件。 podSpec 官方解释: A Podspec, or Spec, describes a version of a Pod library. ，其实就是一个描述 pod 库的信息(版本，依赖，作者，描述，系统库等)的文件。 配置 SJTutorialSDK.podspec 123456789101112131415161718192021222324252627282930313233343536Pod::Spec.new do |s| s.name = "podSDK" s.version = "0.0.1" s.summary = "当前库的总结。" s.description = &lt;&lt;-DESC描述文件 DESC s.homepage = "http://EXAMPLE/podSDK" s.license = "MIT" s.author = &#123; "shmily" =&gt; "shmilyshijian@foxmail.com" &#125; s.platform = :ios, "9.0" s.source = &#123; :git =&gt; "https://github.com/515783034/podSDK.git", :tag =&gt; "#&#123;s.version&#125;" &#125; s.resources = "podSDK/Resources/*.*" # 本库提供的framework静态库 s.vendored_frameworks = 'podSDK/Sources/*.framework' ################# # 依赖的系统动态库 # s.frameworks = "SomeFramework", "AnotherFramework" # 依赖的系统静态库 # s.libraries = "iconv", "z" # 本库提供的 .a 静态库 #s.vendored_libraries = 'podSDK/Sources/*.a' # 本库添加的第三方依赖库 #s.dependency "SJLineRefresh", "~&gt; 1.4"end 关于 podspec 的内容，可以查看我之前写过的文章：创建公共/私有pod –podspec，这里也不再过多赘述。由于当前仓库只是引用了几个静态库，所以 sources 可以不配置，只需要配置 vendored_frameworks 即可。 验证配置是否合理 12pod lib lint# 如果验证中有警告，可以添加参数 --allow-warnings 可以忽略 trunk push 12pod trunk push SJTutorialSDK.podspec# 忽略警告的方式同上 版本控制(tag) 123git tag -m "desc" 1.0.0git push --tag# podspec 中修改对应的 s.version 上传成功，enjoy 123456🎉 Congrats🚀 podSDK (0.0.1) successfully published📅 March 19th, 05:04🌎 https://cocoapods.org/pods/podSDK👍 Tell your friends! 总结静态库的创建并没有太复杂的操作，主要步骤如下： 创建 Cocoa Touch Framework，添加对应文件； 暴露出需要对外公开的头文件； 添加资源文件 Bundle，并提供相应的获取方法； 在真机和模拟器下分别编译，然后合并 framework； pod trunk push. 资源创建静态库demo: SJTutorialSDK 静态库使用 demo: podSDK iOS开发-.a与.framework区别？ iOS 中的 armv7,armv7s,arm64,i386,x86_64 都是什么 创建公共/私有pod –podspec]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>静态库</tag>
        <tag>pod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 scrapy 爬微信公众号的内容]]></title>
    <url>%2F2018%2F02%2F06%2F%E7%94%A8%20scrapy%20%E7%88%AC%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9A%84%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[抓包工具配置1. Fiddler(windows) 安装：https://www.telerik.com/download/fiddler 配置： 12345678910111213# 1. 允许远程连接Tools &gt; Fiddler Options &gt; Connections &gt; Allow remote computers to connect# 2. 支持 HTTPSTools &gt; Fiddler Options &gt; HTTPS &gt; Decrypt HTTPS traffic# 3. 重启restart Fiddler# 4. 手机配置手机 wifi 设置代理，服务器地址为为电脑 ip 地址 xxx.xxx.xxx.xxx，端口为 8888# 5. 下载根证书safari 打开 xxx.xxx.xxx.xxx:8888， 下载安装根证书# 6. 完全信任证书设置 &gt; 通用 &gt; 关于本机 &gt; 证书信任设置 &gt; 针对根证书启用完全信任 2.Charles(MacOS) 安装：Charles Web Debugging Proxy 配置： 1234567891011# 1. 手机配置手机 wifi 设置代理，服务器地址为为电脑 ip 地址 xxx.xxx.xxx.xxx，端口为 8888# 2. 手机安装 SSL 证书Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Devicesafari 打开地址 chls.pro/ssl，下载根证书# 3. 完全信任证书设置 &gt; 通用 &gt; 关于本机 &gt; 证书信任设置 &gt; 针对根证书启用完全信任# 4. 设置ProxyProxy -&gt; SSL Proxying Settings...，勾选 Enable SSL Proxying# 5. 添加域名Host: https://mp.weixin.qq.com Port: 443 scrapy(python package) 使用 官网介绍： 12An open source and collaborative framework for extracting the data you need from websites.In a fast, simple, yet extensible way. 使用： 1234567891011121314151617181920212223242526272829303132333435# 1. 创建项目 WCSpiderscrapy startproject WCSpider# 2. 切换到项目目录cd WCSpider# 3. 创建爬虫 wechatscrapy genspider wechat mp.qq.com# 4. 设置 Agent在 settings 中打开 Agent 注释# 5. 添加 item在 items.py 中完成 item 创建 name = scrapy.Field age = scrapy.Field ... # 6. 解析 response设置 start_urls在 wechat.py 中解析 response, 返回item res = response.xpath(...) item['name'] = res['_name'] item['age'] = res['_age'] ... yield item # 7. 设置管道文件在 open_spider 初始化数据库等 self.f = open("file.json","w")在 close_spider 关闭数据库等 self.f.close()在 deal_spider 处理 item self.f.write(json.dumps(dict(item)))在 settings 中启用该管道文件 公众号历史消息抓包本次抓包以 Charles 为例。 1.获取首页链接 如上图所示，需要的内容在 var msgList = ‘{…}’ 中，由于并不是标准 html，所以这里 xpath 并不好用，可尝试正则表达式快速取出内容。 123rex = "msgList = '(&#123;.*?&#125;)'"pattern = re.compile(pattern=rex, flags=re.S)match = pattern.search(response.text) 取出并格式化匹配项，本例中公众号中的内容都是以文本的形式发送，所以直接取 comm_msg_info 内容，具体请根据实际情况解析。 12345678910111213141516if match: data = match.group(1) data = html.unescape(data) data = json.loads(data) articles = data.get("list") item = WechatItem() for article in articles: info = article["comm_msg_info"] content = html.unescape(info["content"]) # 将获取的数据传递给管道 item["content"] = content item["we_id"] = info["id"] item["datetime"] = info["datetime"] item["we_type"] = info["type"] yield item 2. 获取上拉刷新链接向上滚动历史列表，当到接近最底部时，会自动获取更多内容，此时可以通过抓包获取内容。 如图所示，返回的是 json 格式内容，通过 can_msg_continue 确定是否有后续内容，general_msg_list 是解析的内容。通过分析多个加载历史可知，offset 控制加载数据的位置。–本例中使用 python 第三方库 requests 加载数据 12345678910111213141516def getMore(): # header header = sj_utils.header2dict(base_header) response = requests.get(getUrl(),headers = header, verify = False) js = json.loads(response.text) if js["errmsg"] == "ok": alist = js["general_msg_list"] # 内容是 json 字符串，需要先转为 json alist = json.loads(alist)["list"] for item in alist: # 具体处理 print(item["comm_msg_info"]["content"]) if js["can_msg_continue"]: url_offset += 10 # 设置偏移量 getMore() 3.处理数据开头已经介绍了 scrapy 使用，通过管道文件可以轻松处理爬取内容。 12# 保存 json 文件self.f.write(json.dumps(dict(item))) 参考 基于 Python 实现微信公众号爬虫]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>scrapy</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 swift 中接入微信开源库 Mars]]></title>
    <url>%2F2017%2F12%2F08%2F%E5%9C%A8swift%E4%B8%AD%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%BA%90%E5%BA%93Mars%2F</url>
    <content type="text"><![CDATA[1 介绍1.1 marsmars是微信官方的跨平台跨业务的终端基础组件。 comm：可以独立使用的公共库，包括 socket、线程、消息队列、协程等； xlog：高可靠性高性能的运行期日志组件； SDT： 网络诊断组件； STN： 信令分发网络模块，也是 Mars 最主要的部分。 1.2 protobufprotobuf: Google’s data interchange format.protobuf是google提供的一个开源序列化框架，类似于XML，JSON这样的数据表示语言，其最大的特点是基于二进制，因此比传统的XML表示高效短小得多。虽然是二进制数据格式，但并没有因此变得复杂，开发人员通过按照一定的语法定义结构化的消息格式，然后送给命令行工具，工具将自动生成相关的类，可以支持php、java、c++、python等语言环境。通过将这些类包含在项目中，可以很轻松的调用相关方法来完成业务消息的序列化与反序列化工作。 2 创建framework2.1 生成framework1234567891011// 下载 mars 仓库: git clone https://github.com/Tencent/mars.git// 切换到 libraries路径cd mars-master/mars/libraries// 执行python脚本python build_apple.py 提示输入保存文件夹的前缀:(随意) input prefix for save directory. like trunk,br,tag: 选择build的类型: 1代表iphone版mars(其中包括xlog) Enter menu: build mars for iphone. 2.2 引入framework// log_crypt.cc.rewriteme, log_crypt.h 这两个文件已被废弃,可直接删除 1234// 删除.rewriteme的后缀共三个文件log_crypt.cc.rewriteme(废弃),longlink_packer.cc.rewriteme, shortlink_packer.cc.rewriteme// 拖入工程,并添加库SystemConfiguration, CoreTelephony, Foundation, libz.tbd, libresolv9.tbd 2.3 xlog123456789/// 添加文件(demo中有)LogHelper.h(.mm)、LogUtil.h(.mm), appender-swift-bridge.h(.mm)/// 桥接头文件添加#import &quot;appender-swift-bridge.h&quot;// 配置xlog, 参数分别代表:debug时记录的级别,release时记录的级别,保存文件的相对路径,文件前缀JinkeyMarsBridge().initXlogger(...)// 自定义logJinkeyMarsBridge().log(...) 在didFinishLaunchingWithOptions配置xlog在applicationWillTerminate中destory 2.4 引入protobuf2.4.1 生成.pb.swift123456789// 安装protobufbrew install protobuf// 安装swift-protobuf-plugin git clone https://github.com/apple/swift-protobuf.git cd swift-protobuf swift build -c release -Xswiftc -static-stdlib// 将.proto文件转换成.swiftprotoc --swift_out=. name.proto 写了个shell,可以批量将当前文件夹下的所有.proto转换成对应的.pb.swift地址为install.sh,可直接双击使用内容如下: 12345678910cd $(cd `dirname $0`; pwd)for i in find *.protodo if [ $i == "find" ]; then continue fi protoc --swift_out=. $i echo "生成文件:$i.pb.swift"done 2.4.2 引入.pb.swiftswift-protobuf: Plugin and runtime library for using protobuf with Swift 123456789// pod引用pod &apos;SwiftProtobuf&apos;// 将.pb.swift添加到工程中(不用添加.proto)// 使用var con = Conversation()con.name = &quot;ashen&quot;con.notice = &quot;for test&quot;// 传输时,直接传递data数据let data = try? con.serializedData() 2.5 添加桥接文件(可选)由于该framework是C++写的,对于不会C++的人(比如我)来说, 调用是个很大的问题, 可以通过demo中的相关文件 + swift-oc桥接头文件直接转换成swift可以直接调用的类 3 xlog文件解析3.1 安装python依赖库.首先需要查看自己的python版本, decode_mars_crypt_log_file.py只在python2.+下支持,3.+不能正常运行 安装依赖库pyelliptic, 如果同时存在2.+ 和3.+ 版本,请使用pip2pyelliptic的最新版本1.5.8,存在bug, 需要指定版本为1.5.7 1pip install pyelliptic==1.5.7 3.2 解密logger日志12345// 切换到crypt文件夹cd mars/mars/log/crypt// 解密loggerpython2 decode_mars_crypt_log_file.py logger_20171205.xlog// logger_20171205.xlog.log 即为解密出的log日志 fix bugs: ImportError: No module named pyelliptic 原因:没有正确安装pyelliptic的依赖库 解决: pip2 install pyelliptic==1.5.7 如果安装后依然报错,可能是由于安装了多个版本的python,pyelliptic并没有安装在2.+的python下.在MacOS上, 如果同时安装了2.+ 和3.+的python, pip2 和pip3 分别代表安装到2.+ 和3.+的库中. 所以可以通过pip2 install pyelliptic==1.5.7 安装 AttributeError: dlsym(0x7fc443f02f50, EVP_CIPHER_CTX_reset): symbol not found原因: pyelliptic的最新版本1.5.8的bug解决: 使用1.5.7版本12pip uninstall pyellipticpip install pyelliptic==1.5.7 资源 示例代码 批量转proto 参考: Swift 接入微信 Mars_Xlogger 填坑指南——Jinkey 原创]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>scrapy</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我用Xcode +python写的第一个OS X app]]></title>
    <url>%2F2017%2F11%2F09%2F%E6%88%91%E7%94%A8Xcode%20%2Bpython%E5%86%99%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAOS%20X%20app%2F</url>
    <content type="text"><![CDATA[前两天刚订阅了bestswifter大大的小专栏，其中《2018 年将至，ios 工程师如何自我提高》这篇文章使我感触颇深，最近刚好开始看python, 就萌生了写一个python脚本练练手的想法。 1. 为什么要写这个app？ 原因之一当然是学了点东西总想练练手。 更为重要的原因则是，在写iOS app时，每增加一个网络请求，就要写一个json对应的model类，而构造这些model类的代码毫无快感可言。so，人生苦短，我用python 2. 技术栈python最最最基础知识1. json反序列化将输入的json字符串转成对应的字典(dict) + 数组(list)组合的形式 1res = json.loads(&quot;输入的json字符串&quot;) 2. 字符串操作 解析字典和数组内容，生成swift对应的字符串，拼接起来即可 1234567891011# 遍历字典for (key, value) in dic.items():# 转换成swift格式if isinstance(value, str): return &quot;String&quot;elif isinstance(value, float): return &quot;Float&quot;# 字符串数组拼接result= &apos;&apos;.join([line+&apos;\n&apos; for line in res]) 推荐两个不错学习资源：Python 简单入门指北（试读），Python教程- 廖雪峰 Cocoa APP生成1. 界面搭建Mac OS的界面搭建和iOS超级相似，如果会iOS编程，3分钟就能搞定，这里不做赘述。 2. 图标生成制作一个1024*1024的图片，我习惯使用pixelmator，个人感觉比较简单上手，然后生成若干张对应尺寸的图标，这种app有很多，我用的是Prepo 3. Cocoa 运行python脚本NSTask已经被废弃，应该使用Process()执行脚本文件 123456789101112131415161718192021222324252627let buildTask = Process()let outPip = Pipe()let errorPipe = Pipe()buildTask.launchPath = &quot;/usr/bin/python&quot;// arguments是[String]类型，第一个元素应该为xx.py的路径，后面元素为该py接受的参数buildTask.arguments = argsbuildTask.standardInput = Pipe()buildTask.standardOutput = outPipbuildTask.standardError = errorPipe// 脚本执行完毕后的回调buildTask.terminationHandler = &#123; p in self.taskFinish()&#125;buildTask.launch()buildTask.waitUntilExit()// 脚本的输出结果，即脚本文件的print()方法打印的内容let data = outPip.fileHandleForReading.readDataToEndOfFile()let output = String(data: data, encoding: String.Encoding.utf8) // 错误处理, python系统错误let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()let errorStr = String(data: errorData, encoding: String.Encoding.utf8)if let aError = errorStr, aError != &quot;&quot; &#123; sendError(&quot;解析错误\r\n&quot; + aError)&#125; arguments：脚本参数 let scripyPath = Bundle.main.path(forResource: “Parse”, ofType: “py”)! // 脚本路径let para1 = “input info” // 传入参数，通过sys.argv[I]获取let args = [scripyPath, para1]buildTask.arguments = args standardOutput：脚本输出 执行脚本后可通过output获取结果注意：脚本的返回结果不是通过函数的return，而是通过调用print(infos)函数，即infos作为结果返回let data = outPip.fileHandleForReading.readDataToEndOfFile()let output = String(data: data, encoding: String.Encoding.utf8) standardError: 错误输出 解决python的exception信息task.terminationStatus 不等于0也能判断为失败 3. 封装 Cocoa 运行python脚本的代码，写起来虽然不算特别麻烦，但总也说不是简洁，于是重新封装了一个类方便调用：CocoaPython使用如下： 12let script = CocoaPython(scrPath: pyPath)script.runAsync() 详细说明： 1234567891011121314// python脚本文件路径guard let aPath = Bundle.main.path(forResource: "Parse", ofType: "py") else &#123; return &#125;// args: py文件接受的参数列表，通过sys.argv[i]访问// block: 完成后的回调，包括返回值和错误内容let script = CocoaPython(scrPath: aPath, args: [""]) &#123; [weak self] in print($0) // 返回值，所有的py中print()的内容 print($1) // py中的错误信息&#125;script.spliPara = "$" // 如果有多个结果，每个结果之间的分隔符，不设置则将所有的结果当成一个结果返回，即result == result[0]script.runAsync() // 异步执行，回调在异步主线程中调用// or script.runAsync(asyncComlete: false) // 异步执行，回调在global中执行// or script.runSync() // 同步执行 4. 资源github地址: json2swiftOS X app: json2Swift.apppython 脚本: json2Swift.py]]></content>
      <categories>
        <category>macos</category>
      </categories>
      <tags>
        <tag>macos</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
