<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一次 Cocoa App(macOS App)开发尝试</title>
      <link href="/2019/03/01/try-macos-app/"/>
      <url>/2019/03/01/try-macos-app/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/03/01/5c789338173aa.png" alt></p><p>“我们从小就听长辈们说起过懒汉，仿佛懒惰很不体面。实际上，没有我们的这些懒汉，恐怕就没有社会的进步；没有我们的这些懒汉，勤劳的人面对的恐怕只会是单调乏味的劳作。”这里引入小学课本学过的文章《懒惰的智慧》中的一句话，深以为这句话就是对我们程序员群体的真实写照，促进社会进步说的有点夸张，但是提高生产效率还是不在话下的，这也是我本次纪录的一点儿动力。</p><p>好好的开发 iOS，为什么要玩玩 macOS 呢？自我揣测每一位 iOSer 的内心中都有一个开发 macOS 的冲动，毕竟工具(mac + Xcode)和基础技术(Objective-C, Swift)都是现成的，iOS 开发的应用需要上架才能使用，而 mac App 甚至都可以省略上架这一步，在朋友间传播起来也方便得多。</p><p>闲话少说，今天谈谈最近一次开发的 macOS App <a href="https://itunes.apple.com/cn/app//id1445645840?mt=12" target="_blank" rel="noopener">开发者之刃 App Store</a>、<a href="https://www.juanji.xyz/" target="_blank" rel="noopener">开发者之刃 首页</a>。</p><a id="more"></a><p><img src="https://i.loli.net/2019/03/01/5c7898fdf32fd.png" alt="App Store 页介绍"></p><p>功能包括：</p><ul><li>色盘(存储配色方案)</li><li>图标生成器（生成 iOS/macOS/Android 多尺寸图标文件）</li><li>图像压缩（基于 <a href="https://tinypng.com/" target="_blank" rel="noopener">TinyPng</a>）</li><li>json 转模型(json 字符串转成 swift 模型对象)</li><li>开源库集（github 开源库分类整理）等功能</li><li>支持开机自启动、全局快捷键、自动检查更新等。</li></ul><h3 id="1-从技术的角度谈谈做了什么"><a href="#1-从技术的角度谈谈做了什么" class="headerlink" title="1. 从技术的角度谈谈做了什么"></a>1. 从技术的角度谈谈做了什么</h3><h4 id="1-1-开发了一款-macOS-App"><a href="#1-1-开发了一款-macOS-App" class="headerlink" title="1.1 开发了一款 macOS App"></a>1.1 开发了一款 macOS App</h4><p>主要采用 Swift4.2 编写“开发者之刃”，相比于 OC，Swift 的优势想必用过的朋友们都知道。</p><p>“开发者之刃”的技术点大概如下：</p><ul><li><code>CocoaPods</code>管理第三方开源库<ul><li><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a> 网络框架</li><li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">CocoaLumberjack/Swift</a> 日志纪录</li><li><a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="noopener">SnapKit</a> 自动布局</li><li><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener">Kingfisher</a> 网络图片加载缓存</li><li><a href="https://fabric.io/kits" target="_blank" rel="noopener">Fabric</a> bug 及用户行为分析</li><li><a href="https://github.com/sindresorhus/LaunchAtLogin" target="_blank" rel="noopener">LaunchAtLogin</a> 开机自启动</li></ul></li><li>全局快捷键：主要用到 <code>RegisterEventHotKey</code>方法</li><li>Python 和 Swift 交互：可以看下之前写的文章<a href="https://xiaozhuanlan.com/topic/7365091284" target="_blank" rel="noopener">《我用 Xcode+python 写的第一个 OSX app》</a>，关键词：<code>Process</code></li><li>本地缓存：未使用数据库，采用 json 格式存本地文件，使用的库：<a href="https://github.com/tristanhimmelman/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a></li></ul><p>对于没有开发mac 经验的同学，推荐剑指人心的 <a href="https://macdev.io/" target="_blank" rel="noopener">《macOS 应用开发基础教程》</a>，入门是完完全全没有问题的。“开发者之刃”里面用到的技术基本上都能在这本书中找到，而且从完全没有 mac App 开发经验到上架一个完整的 App，本人是照着书中内容一步步走下来的，这里也一并感谢下作者。</p><h4 id="1-2-顺手撸了个服务端"><a href="#1-2-顺手撸了个服务端" class="headerlink" title="1.2 顺手撸了个服务端"></a>1.2 顺手撸了个服务端</h4><p>采用 Python 的 Flask 库搭建的服务端，操作简单，功能全面。IDE 用的是 <a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="noopener">PyCharm</a>。</p><p>这里为什么要用“顺手”二字呢？实实在在是没有服务端的开发经验，在网易云课堂上看了一个教程，操起键盘就是干。中间遇到问题就 Google 一下，不能解决的就直接绕过去了，所以到最后功能既不完善，也不系统，但也勉强够用。毕竟精力有限，以完善功能为主，系统性的学习还任重而道远。</p><p>服务端的技术点大概如下：</p><ul><li>pip: 包管理工具<ul><li><a href="http://flask.pocoo.org/" target="_blank" rel="noopener">Flask</a>: Web 开发微框架</li><li><a href="https://github.com/zzzeek/sqlalchemy" target="_blank" rel="noopener">SQLAlchemy</a>: 数据库工具</li><li><a href="https://github.com/miguelgrinberg/Flask-Migrate" target="_blank" rel="noopener">Flask-Migrate</a>: 数据库升级工具</li></ul></li><li>http 请求、web 页面：Flask 很容易实现</li><li><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a>: 渐进式 JavaScript 框架，快速构建 web 页面</li></ul><p>半吊子都算不上的服务端开发，这里就不班门弄斧了，基本功能大概如上所诉。照着网易云上的视频 <a href="https://study.163.com/course/courseMain.htm?courseId=1004091002" target="_blank" rel="noopener">Python Flask系列（1）——基础</a> 学习的 Flask 基础，感觉讲的挺好，浅显易懂，写个简简单单的页面是完全足够了。</p><h4 id="1-3-切了几张图"><a href="#1-3-切了几张图" class="headerlink" title="1.3 切了几张图"></a>1.3 切了几张图</h4><p>图可以切，审美就不不必较真了。</p><p>技术呢也没有用到什么技术(主要是我都不知道有啥技术，完全两眼一抹黑)，这里就简单介绍下用的工具吧。</p><ul><li><a href="https://www.sketchapp.com/" target="_blank" rel="noopener">Sketch</a>：轻量易用的矢量设计工具。易用易用，谁用谁知道。</li><li><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>:矢量图标管理、交流平台。免费图标多种多样，可下载源文件，也可指定颜色、大小下载。</li><li><a href="https://tinypng.com/" target="_blank" rel="noopener">tinypng</a>: 智能有损压缩图片。“开发者之刃”中的图片压缩功能核心就是用的它的服务，压缩率高，压缩后的图像几乎肉眼看不到失真。</li></ul><h3 id="2-谈谈为什么要做这个-App"><a href="#2-谈谈为什么要做这个-App" class="headerlink" title="2. 谈谈为什么要做这个 App"></a>2. 谈谈为什么要做这个 App</h3><p>前面提到了，每个 iOSer 的内心中都有一颗开发 mac App 的心，其实说白了，每一个程序员的内心中都有尝试新事物的冲动。</p><p>确确实实解决开发中的一些痛点。服务端甩给客户端一大串 json，我们每次构建对象时烦不胜烦，机械重复的代码只是在浪费我们有限的生命与激情，所以有了《json 转模型》的想法。设计给的色值一天三变，背景色、基础字体颜色不统一，被他们一句“这个颜色就是之前用的”弄得痛不欲生，自己设计个玩意后，色值转身就忘，所以有了《色盘》的想法。github 看到优秀的仓库也不太想 star，实在是 star 的数量过多，想用的时候像是大海捞针，所以有了《开源库集》的想法。自己写个 App，要被切各个尺寸的图弄疯，切完还得一张张拖到 Assets 中合适的坑中，总之开发中总会遇到一些重复的工作，大概是可以通过代码处理的吧。</p><p>学习真的会使人快乐。当刚开始接触一个新的技术时，汲取知识的快感是强烈的，不论是纯粹的学习还是单纯想炫技，能学到东西总归是一个非常好的结果。当然要深挖技术时的确会有痛苦，痛并快乐着吧。</p><h3 id="3-作一个简单的总结"><a href="#3-作一个简单的总结" class="headerlink" title="3. 作一个简单的总结"></a>3. 作一个简单的总结</h3><p>技术：</p><ul><li>mac App 开发：Swift + Xcode</li><li>web 开发：Python + PyCharm</li><li>切图：iconfont + Sketch</li></ul><p>资源：</p><ul><li><a href="https://www.juanji.xyz/" target="_blank" rel="noopener">开发者之刃 首页</a></li><li><a href="https://macdev.io/" target="_blank" rel="noopener">《macOS 应用开发基础教程》</a></li><li><a href="https://study.163.com/course/courseMain.htm?courseId=1004091002" target="_blank" rel="noopener">Python Flask系列（1）——基础</a></li><li><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a></li><li><a href="https://tinypng.com/" target="_blank" rel="noopener">tinypng</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> macos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macos </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建 iOS 静态库并用 pod 管理</title>
      <link href="/2018/03/20/%E8%87%AA%E5%BB%BA%20iOS%20%E9%9D%99%E6%80%81%E5%BA%93%E5%B9%B6%E7%94%A8%20pod%20%E7%AE%A1%E7%90%86/"/>
      <url>/2018/03/20/%E8%87%AA%E5%BB%BA%20iOS%20%E9%9D%99%E6%80%81%E5%BA%93%E5%B9%B6%E7%94%A8%20pod%20%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="https://diycode.b0.upaiyun.com/photo/2018/7c0aeca1511c21c5573c9b529ff62a7c.png" alt></p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本文将主要讨论如下几个问题：</p><ul><li><ol><li>OC 和 Swift 混编的形式创建支持多种架构的静态库（.framework）；</li></ol></li><li><ol start="2"><li>静态库引用其他静态库（.framework 或 .a)；</li></ol></li><li><ol start="3"><li>静态库添加资源文件；</li></ol></li><li><ol start="4"><li>pod 管理静态库。</li></ol></li></ul><h2 id="创建静态库-framework"><a href="#创建静态库-framework" class="headerlink" title="创建静态库 framework"></a>创建静态库 framework</h2><p>最近公司由于和其他公司建立了各种合作关系，“创建 SDK”工作被提上了日程，由于之前没有自己做过，在生成 framework 时踩了一些坑，在这里记录下来以做总结，若码友能用得上则不胜开心。<br>工作中难免会遇到这种情况，想把某个功能包装起来给其他人用，但是出于某种原因又不想公开自己的实现方式，这时就需要静态库（framework 或 .a）了。(PS：.a 和 .framework 的区别可以看下这篇文章：<a href="https://www.jianshu.com/p/4a455425aae8" target="_blank" rel="noopener">iOS开发-.a与.framework区别？</a></p><a id="more"></a><h3 id="创建静态库"><a href="#创建静态库" class="headerlink" title="创建静态库"></a>创建静态库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XCode -&gt; File -&gt; New -&gt; Project -&gt; Cocoa Touch Framework</span><br></pre></td></tr></table></figure><p><img src="https://diycode.b0.upaiyun.com/photo/2019/2dec3fb8bd982563a3fc73d7d44d8015.png" alt="创建"></p><p>创建 SJTutorialSDK，并新建测试类名为 HelloWorld（Swift）、HelloOC(OC)，目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── SJTutorialSDK</span><br><span class="line">│   ├── HelloOC.h                -&gt; 暴露的 OC 类</span><br><span class="line">│   ├── HelloOC.m</span><br><span class="line">│   ├── HelloWorld.swift         -&gt; 暴露的 Swift 类</span><br><span class="line">│   ├── Info.plist</span><br><span class="line">│   └── SJTutorialSDK.h          -&gt; 当前静态库头文件</span><br><span class="line">└── SJTutorialSDK.xcodeproj</span><br><span class="line">    ├── project.pbxproj</span><br><span class="line">    ├── project.xcworkspace</span><br><span class="line">    │   ├── contents.xcworkspacedata</span><br><span class="line">    │   └── xcuserdata</span><br><span class="line">    │       └── shijian.xcuserdatad</span><br><span class="line">    │           └── UserInterfaceState.xcuserstate</span><br><span class="line">    └── xcuserdata</span><br><span class="line">        └── shijian.xcuserdatad</span><br><span class="line">            └── xcschemes</span><br><span class="line">                └── xcschememanagement.plist</span><br></pre></td></tr></table></figure><ul><li><ol><li>对于 Swift，对外暴露的文件需要用 public（或 open）修饰，并且要继承自 NSObject(或其子类)；</li></ol></li><li><ol start="2"><li>对于 OC，对外暴露的文件需要在“Build Phases -&gt; Headers -&gt; Public”添加相应头文件（例：HelloOC.h），并在 framework 的头文件（例：SJTutorialSDK.h）中添加对该头文件的引用(例：#import &lt;SJTutorialSDK/HelloOC.h&gt;)；</li></ol></li><li><ol start="3"><li>如果当前 framework 引用了第三方 framework，需要在头文件（例：SJTutorialSDK.h）中添加对第三方头文件的引用（例：#import &lt;SJDemoSDK/Animals.h&gt;)。</li></ol></li></ul><p>创建完成后的头文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//  SJTutorialSDK.h</span><br><span class="line">//  SJTutorialSDK</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">FOUNDATION_EXPORT double SJTutorialSDKVersionNumber;</span><br><span class="line">FOUNDATION_EXPORT const unsigned char SJTutorialSDKVersionString[];</span><br><span class="line"></span><br><span class="line">// 第三方库的头文件</span><br><span class="line">#import &lt;SJDemoSDK/Animals.h&gt;</span><br><span class="line"></span><br><span class="line">// 对外暴露的头文件（仅限于 OC，Swift 添加 public 后会自动导入）</span><br><span class="line">#import &lt;SJTutorialSDK/HelloOC.h&gt;</span><br></pre></td></tr></table></figure><p>Build Phases 配置如下：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/35a5ad148eeba175637917bf717efc01.png" alt="header"></p><p>至此，静态库.framework 创建完毕。</p><h3 id="支持多种架构"><a href="#支持多种架构" class="headerlink" title="支持多种架构"></a>支持多种架构</h3><p>我们开发过程中经常提到的 arm64，x86_64 具体是什么东西呢？这里可以参考这篇文章: <a href="https://www.jianshu.com/p/3fce0bd6f045" target="_blank" rel="noopener">iOS 中的 armv7,armv7s,arm64,i386,x86_64 都是什么</a>。简单点来说：模拟器 32/64 位处理器分别需要 i386/x86_64 架构，真机 32/64 位处理器分别需要 armv7(armv7s)/arm64 架构。<br>所以，如果你构建的静态库只需要支持 iPhone 5S 及以上(或 iPad mini2 及以上)的真机和模拟器，那么你的静态库将只需支持 arm64 和 x86_64 架构。</p><ul><li><ol><li>调整到 Release(发布)模式：Edit Scheme -&gt; Run -&gt; Info -&gt; Build Configuration -&gt; Release；<br><img src="https://diycode.b0.upaiyun.com/photo/2019/a733d9e616b3c12211c14c1bf70e336b.png" alt="release mode"></li></ol></li><li><ol start="2"><li>分别使用真机、模拟器编译，生成对应的 SJTutorialSDK.framework；</li></ol></li><li><ol start="3"><li>合并 frameworks</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看静态库支持的架构</span><br><span class="line">lipo -info xxx</span><br><span class="line"></span><br><span class="line"># 合并 xxx1 和 xxx2，最后的文件支持两者支持的所有架构</span><br><span class="line">lipo -create xxx1 xxx2 -output xxx1</span><br><span class="line">eg:</span><br><span class="line">lipo -creat Release-iphoneos/SJTutorialSDK.framework/SJTutorialSDK Release-iphonesimulator/SJTutorialSDK.framework/SJTutorialSDK -output Release-iphoneos/SJTutorialSDK.framework/SJTutorialSDK</span><br></pre></td></tr></table></figure><p>生成 framework 时踩过的坑：-output 的文件是 xxx，而不是 xxx.framework</p><ul><li><ol start="4"><li>查看最后的静态库支持架构:</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Architectures in the fat file: /Users/shijian/Desktop/SJTutorialSDK.framework/SJTutorialSDK are: x86_64 arm64</span><br><span class="line"># congratulations</span><br></pre></td></tr></table></figure><h3 id="添加资源文件"><a href="#添加资源文件" class="headerlink" title="添加资源文件"></a>添加资源文件</h3><p>在 iOS 中，可以通过 Bundle 文件管理资源文件(图片，语音，视频，plist，xib，storyboard等)，Bundle 文件实际上就是个普通的文件夹，只是在名字中添加了 .Bundle 的后缀而已。<br>对图片的命名最好添加上 @3x/@2x，这样系统会自动放在对应的位置，不需要我们额外的操作。</p><ul><li><ol><li>新建文件夹 xxx，并添加相应资源，然后更名为 xxx.Bundle，也可以直接新建 xxx.Bundle，鼠标右键 -&gt; 显示包内容 -&gt; 添加相应文件；</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── SJTutorialRes.Bundle</span><br><span class="line">    ├── alipay@3x.png</span><br><span class="line">    └── wechat@3x.png</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>新建方法读取 Bundle 中的图片</li></ol></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 以使外界能够访问</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TutorialRes</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getImg</span><span class="params">(<span class="number">_</span> name: String)</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">Bundle</span>(<span class="keyword">for</span>: <span class="type">TutorialRes</span>.<span class="keyword">self</span>).url(forResource: <span class="string">"SJTutorialRes"</span>, withExtension: <span class="string">"Bundle"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> path = <span class="type">Bundle</span>(url: url)?.path(forResource: name, ofType: <span class="literal">nil</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIImage</span>(contentsOfFile: path)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">aliImg</span><span class="params">()</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getImg(<span class="string">"alipay@3x.png"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">WechatImg</span><span class="params">()</span></span> -&gt; <span class="type">UIImage?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getImg(<span class="string">"wechat@3x.png"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，静态库已经创建完毕，当前创建的静态库 SJTutorialSDK 有如下特性：支持 OC 和 Swift 混编，引用了其他第三方库，支持资源文件读取，支持多种架构。</p><h2 id="pod-管理静态库"><a href="#pod-管理静态库" class="headerlink" title="pod 管理静态库"></a>pod 管理静态库</h2><p>如果自己的静态库是私有的，可以跳过 trunk 环节，直接在自己的代码仓库中创建好仓库，然后配置相应的 podspec 文件，pod 引用时指定对应的路径即可。但大多数情况下还是要给其他人使用的，我们当然也可以不通过 trunk，直接在引用时指定地址来使用当前仓库，但是这样用起来总是不那么直观。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 通过名称和指定地址使用</span><br><span class="line">pod 'SJTutorialSDK',:git =&gt; "git@code.XXX/SJTutorialSDK.git"</span><br><span class="line"><span class="meta">#</span> 通过名称</span><br><span class="line">pod 'SJTutorialSDK'</span><br></pre></td></tr></table></figure><p>两者对比起来，高下立判。所以建议还是通过 trunk 来 push 自己的代码。</p><h3 id="配置-podspec-文件"><a href="#配置-podspec-文件" class="headerlink" title="配置 podspec 文件"></a>配置 podspec 文件</h3><p>如何在 github 上新建仓库，网上已经有很多的教程，这里不再赘述，这里主要谈谈配置 podspec 文件。</p><p>podSpec 官方解释: <a href="http://guides.cocoapods.org/making/specs-and-specs-repo.html" target="_blank" rel="noopener">A Podspec, or Spec, describes a version of a Pod library.</a> ，其实就是一个描述 pod 库的信息(版本，依赖，作者，描述，系统库等)的文件。</p><ul><li><ol><li>配置 SJTutorialSDK.podspec</li></ol></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  s.name         = "podSDK"</span><br><span class="line">  s.version      = "0.0.1"</span><br><span class="line">  s.summary      = "当前库的总结。"</span><br><span class="line"></span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line">描述文件</span><br><span class="line">                   DESC</span><br><span class="line"></span><br><span class="line">  s.homepage     = "http://EXAMPLE/podSDK"</span><br><span class="line">  s.license      = "MIT"</span><br><span class="line">  s.author             = &#123; "shmily" =&gt; "shmilyshijian@foxmail.com" &#125;</span><br><span class="line">  s.platform     = :ios, "9.0"</span><br><span class="line">  s.source       = &#123; :git =&gt; "https://github.com/515783034/podSDK.git", :tag =&gt; "#&#123;s.version&#125;" &#125;</span><br><span class="line"></span><br><span class="line">  s.resources = "podSDK/Resources/*.*"</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span> 本库提供的framework静态库</span><br><span class="line">  s.vendored_frameworks = 'podSDK/Sources/*.framework'</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span>################</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span> 依赖的系统动态库</span><br><span class="line"><span class="meta">  #</span> s.frameworks = "SomeFramework", "AnotherFramework"</span><br><span class="line"><span class="meta">  #</span> 依赖的系统静态库</span><br><span class="line"><span class="meta">  #</span> s.libraries = "iconv", "z"</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span> 本库提供的 .a 静态库</span><br><span class="line"><span class="meta">  #</span>s.vendored_libraries  = 'podSDK/Sources/*.a'</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span> 本库添加的第三方依赖库</span><br><span class="line"><span class="meta">  #</span>s.dependency "SJLineRefresh", "~&gt; 1.4"</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>关于 podspec 的内容，可以查看我之前写过的文章：<a href="https://www.jianshu.com/p/1139a603f413" target="_blank" rel="noopener">创建公共/私有pod –podspec</a>，这里也不再过多赘述。<br>由于当前仓库只是引用了几个静态库，所以 sources 可以不配置，只需要配置 vendored_frameworks 即可。</p><ul><li><ol start="2"><li>验证配置是否合理</li></ol></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br><span class="line"><span class="meta">#</span> 如果验证中有警告，可以添加参数 --allow-warnings 可以忽略</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>trunk push</li></ol></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push SJTutorialSDK.podspec</span><br><span class="line"><span class="meta">#</span> 忽略警告的方式同上</span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li>版本控制(tag)</li></ol></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag -m "desc" 1.0.0</span><br><span class="line">git push --tag</span><br><span class="line"><span class="meta">#</span> podspec 中修改对应的 s.version</span><br></pre></td></tr></table></figure><p>上传成功，enjoy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">🎉  Congrats</span><br><span class="line"></span><br><span class="line">🚀  podSDK (0.0.1) successfully published</span><br><span class="line">📅  March 19th, 05:04</span><br><span class="line">🌎  https://cocoapods.org/pods/podSDK</span><br><span class="line">👍  Tell your friends!</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>静态库的创建并没有太复杂的操作，主要步骤如下：</p><ul><li><ol><li>创建 Cocoa Touch Framework，添加对应文件；</li></ol></li><li><ol start="2"><li>暴露出需要对外公开的头文件；</li></ol></li><li><ol start="3"><li>添加资源文件 Bundle，并提供相应的获取方法；</li></ol></li><li><ol start="4"><li>在真机和模拟器下分别编译，然后合并 framework；</li></ol></li><li><ol start="5"><li>pod trunk push.</li></ol></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="https://github.com/515783034/ArticleCode/tree/master/SJTutorialSDK" target="_blank" rel="noopener">创建静态库demo: SJTutorialSDK</a></p><p><a href="https://github.com/515783034/podSDK.git" target="_blank" rel="noopener">静态库使用 demo: podSDK</a></p><p><a href="https://www.jianshu.com/p/4a455425aae8" target="_blank" rel="noopener">iOS开发-.a与.framework区别？</a></p><p><a href="https://www.jianshu.com/p/3fce0bd6f045" target="_blank" rel="noopener">iOS 中的 armv7,armv7s,arm64,i386,x86_64 都是什么</a></p><p><a href="https://www.jianshu.com/p/1139a603f413" target="_blank" rel="noopener">创建公共/私有pod –podspec</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 静态库 </tag>
            
            <tag> pod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 scrapy 爬微信公众号的内容</title>
      <link href="/2018/02/06/%E7%94%A8%20scrapy%20%E7%88%AC%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9A%84%E5%86%85%E5%AE%B9/"/>
      <url>/2018/02/06/%E7%94%A8%20scrapy%20%E7%88%AC%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9A%84%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p><img src="https://diycode.b0.upaiyun.com/photo/2018/d5c2fae2609a20f63ce8874272126d01.png" alt></p><h2 id="抓包工具配置"><a href="#抓包工具配置" class="headerlink" title="抓包工具配置"></a>抓包工具配置</h2><h3 id="1-Fiddler-windows"><a href="#1-Fiddler-windows" class="headerlink" title="1. Fiddler(windows)"></a>1. Fiddler(windows)</h3><ul><li>安装：<a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">https://www.telerik.com/download/fiddler</a></li><li>配置：  </li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 允许远程连接</span></span><br><span class="line">Tools &gt; Fiddler Options &gt; Connections &gt; Allow remote computers to connect</span><br><span class="line"><span class="comment"># 2. 支持 HTTPS</span></span><br><span class="line">Tools &gt; Fiddler Options &gt; HTTPS &gt; Decrypt HTTPS traffic</span><br><span class="line"><span class="comment"># 3. 重启</span></span><br><span class="line">restart Fiddler</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 手机配置</span></span><br><span class="line">手机 wifi 设置代理，服务器地址为为电脑 ip 地址 xxx.xxx.xxx.xxx，端口为 <span class="number">8888</span></span><br><span class="line"><span class="comment"># 5. 下载根证书</span></span><br><span class="line">safari 打开 xxx.xxx.xxx.<span class="symbol">xxx:</span><span class="number">8888</span>， 下载安装根证书</span><br><span class="line"><span class="comment"># 6. 完全信任证书</span></span><br><span class="line">设置 &gt; 通用 &gt; 关于本机 &gt; 证书信任设置 &gt; 针对根证书启用完全信任</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-Charles-MacOS"><a href="#2-Charles-MacOS" class="headerlink" title="2.Charles(MacOS)"></a>2.Charles(MacOS)</h3><ul><li>安装：<a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">Charles Web Debugging Proxy</a></li><li>配置：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 手机配置</span></span><br><span class="line">手机 wifi 设置代理，服务器地址为为电脑 ip 地址 xxx.xxx.xxx.xxx，端口为 <span class="number">8888</span></span><br><span class="line"><span class="comment"># 2. 手机安装 SSL 证书</span></span><br><span class="line">Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device</span><br><span class="line">safari 打开地址 chls.pro/ssl，下载根证书</span><br><span class="line"><span class="comment"># 3. 完全信任证书</span></span><br><span class="line">设置 &gt; 通用 &gt; 关于本机 &gt; 证书信任设置 &gt; 针对根证书启用完全信任</span><br><span class="line"><span class="comment"># 4. 设置Proxy</span></span><br><span class="line">Proxy -&gt; SSL Proxying Settings...，勾选 Enable SSL Proxying</span><br><span class="line"><span class="comment"># 5. 添加域名</span></span><br><span class="line"><span class="symbol">Host:</span> <span class="symbol">https:</span>/<span class="regexp">/mp.weixin.qq.com  Port: 443</span></span><br></pre></td></tr></table></figure><h2 id="scrapy-python-package-使用"><a href="#scrapy-python-package-使用" class="headerlink" title="scrapy(python package) 使用"></a>scrapy(python package) 使用</h2><ul><li>官网介绍：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">An open source and collaborative framework for extracting the data you need from websites.</span><br><span class="line">In a fast, simple, yet extensible way.</span><br></pre></td></tr></table></figure><ul><li>使用：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1. 创建项目 WCSpider</span><br><span class="line">scrapy startproject WCSpider</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 2. 切换到项目目录</span><br><span class="line">cd WCSpider</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 3. 创建爬虫 wechat</span><br><span class="line">scrapy genspider wechat mp.qq.com</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 4. 设置 Agent</span><br><span class="line">在 settings 中打开 Agent 注释</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 5. 添加 item</span><br><span class="line">在 items.py 中完成 item 创建</span><br><span class="line">    name = scrapy.Field</span><br><span class="line">    age = scrapy.Field</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> 6. 解析 response</span><br><span class="line">设置 start_urls</span><br><span class="line">在 wechat.py 中解析 response, 返回item</span><br><span class="line">    res = response.xpath(...)</span><br><span class="line">    item['name'] = res['_name']</span><br><span class="line">    item['age'] = res['_age']</span><br><span class="line">    ...</span><br><span class="line">    yield item</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span> 7. 设置管道文件</span><br><span class="line">在 open_spider 初始化数据库等</span><br><span class="line">    self.f = open("file.json","w")</span><br><span class="line">在 close_spider 关闭数据库等</span><br><span class="line">    self.f.close()</span><br><span class="line">在 deal_spider 处理 item</span><br><span class="line">    self.f.write(json.dumps(dict(item)))</span><br><span class="line">在 settings 中启用该管道文件</span><br></pre></td></tr></table></figure><h2 id="公众号历史消息抓包"><a href="#公众号历史消息抓包" class="headerlink" title="公众号历史消息抓包"></a>公众号历史消息抓包</h2><p>本次抓包以 Charles 为例。</p><h3 id="1-获取首页链接"><a href="#1-获取首页链接" class="headerlink" title="1.获取首页链接"></a>1.获取首页链接</h3><p><img src="https://diycode.b0.upaiyun.com/photo/2018/2f41e5d1a0a4ad2851619b136b6db5f5.png" alt="抓包"></p><p>如上图所示，需要的内容在 var msgList = ‘{…}’ 中，由于并不是标准 html，所以这里 xpath 并不好用，可尝试正则表达式快速取出内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rex = <span class="string">"msgList = '(&#123;.*?&#125;)'"</span></span><br><span class="line">pattern = re.compile(pattern=rex, flags=re.S)</span><br><span class="line">match = pattern.search(response.text)</span><br></pre></td></tr></table></figure><p>取出并格式化匹配项，本例中公众号中的内容都是以文本的形式发送，所以直接取 comm_msg_info 内容，具体请根据实际情况解析。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> match:</span><br><span class="line">    data = match.group(<span class="number">1</span>)</span><br><span class="line">    data = html.unescape(data)</span><br><span class="line">    data = json.loads(data)</span><br><span class="line">    articles = data.get(<span class="string">"list"</span>)</span><br><span class="line"></span><br><span class="line">    item = WechatItem()</span><br><span class="line">    <span class="keyword">for</span> article <span class="keyword">in</span> articles:</span><br><span class="line">        info = article[<span class="string">"comm_msg_info"</span>]</span><br><span class="line">        content = html.unescape(info[<span class="string">"content"</span>])</span><br><span class="line">        <span class="comment"># 将获取的数据传递给管道</span></span><br><span class="line">        item[<span class="string">"content"</span>] = content</span><br><span class="line">        item[<span class="string">"we_id"</span>] = info[<span class="string">"id"</span>]</span><br><span class="line">        item[<span class="string">"datetime"</span>] = info[<span class="string">"datetime"</span>]</span><br><span class="line">        item[<span class="string">"we_type"</span>] = info[<span class="string">"type"</span>]</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><h3 id="2-获取上拉刷新链接"><a href="#2-获取上拉刷新链接" class="headerlink" title="2. 获取上拉刷新链接"></a>2. 获取上拉刷新链接</h3><p>向上滚动历史列表，当到接近最底部时，会自动获取更多内容，此时可以通过抓包获取内容。<br><img src="https://diycode.b0.upaiyun.com/photo/2018/784da6b14584170d45393a0476105e63.png" alt></p><p>如图所示，返回的是 json 格式内容，通过 can_msg_continue 确定是否有后续内容，general_msg_list 是解析的内容。通过分析多个加载历史可知，offset 控制加载数据的位置。<br><strong>–本例中使用 python 第三方库 requests 加载数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMore</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="comment"># header</span></span><br><span class="line">header = sj_utils.header2dict(base_header)</span><br><span class="line">response = requests.get(getUrl(),headers = header, verify = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">js = json.loads(response.text)</span><br><span class="line"><span class="keyword">if</span> js[<span class="string">"errmsg"</span>] == <span class="string">"ok"</span>:</span><br><span class="line">alist = js[<span class="string">"general_msg_list"</span>] <span class="comment"># 内容是 json 字符串，需要先转为 json</span></span><br><span class="line">alist = json.loads(alist)[<span class="string">"list"</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> alist:</span><br><span class="line">  <span class="comment"># 具体处理</span></span><br><span class="line">print(item[<span class="string">"comm_msg_info"</span>][<span class="string">"content"</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> js[<span class="string">"can_msg_continue"</span>]:</span><br><span class="line">   url_offset += <span class="number">10</span> <span class="comment"># 设置偏移量</span></span><br><span class="line">getMore()</span><br></pre></td></tr></table></figure><h3 id="3-处理数据"><a href="#3-处理数据" class="headerlink" title="3.处理数据"></a>3.处理数据</h3><p>开头已经介绍了 scrapy 使用，通过管道文件可以轻松处理爬取内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存 json 文件</span></span><br><span class="line">self.f.write(json.dumps(dict(item)))</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/book/5a157c155188254a701eb3c1" target="_blank" rel="noopener">基于 Python 实现微信公众号爬虫</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> scrapy </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 swift 中接入微信开源库 Mars</title>
      <link href="/2017/12/08/%E5%9C%A8swift%E4%B8%AD%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%BA%90%E5%BA%93Mars/"/>
      <url>/2017/12/08/%E5%9C%A8swift%E4%B8%AD%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E5%BC%80%E6%BA%90%E5%BA%93Mars/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2017/12/8/16033e55aca73b9e?imageView2/2/w/480/h/480/q/85/interlace/1" alt></p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><h3 id="1-1-mars"><a href="#1-1-mars" class="headerlink" title="1.1 mars"></a>1.1 mars</h3><p><a href="https://github.com/Tencent/mars" target="_blank" rel="noopener">mars</a>是微信官方的跨平台跨业务的终端基础组件。</p><ul><li>comm：可以独立使用的公共库，包括 socket、线程、消息队列、协程等；</li><li>xlog：高可靠性高性能的运行期日志组件；</li><li>SDT： 网络诊断组件；</li><li>STN： 信令分发网络模块，也是 Mars 最主要的部分。<a id="more"></a><img src="https://user-gold-cdn.xitu.io/2017/12/7/1602f5e627031bc8?w=885&h=580&f=png&s=64116" alt><h3 id="1-2-protobuf"><a href="#1-2-protobuf" class="headerlink" title="1.2 protobuf"></a>1.2 protobuf</h3><a href="https://github.com/google/protobuf" target="_blank" rel="noopener">protobuf</a>: Google’s data interchange format.<br>protobuf是google提供的一个开源序列化框架，类似于XML，JSON这样的数据表示语言，其最大的特点是基于二进制，因此比传统的XML表示高效短小得多。虽然是二进制数据格式，但并没有因此变得复杂，开发人员通过按照一定的语法定义结构化的消息格式，然后送给命令行工具，工具将自动生成相关的类，可以支持php、java、c++、python等语言环境。通过将这些类包含在项目中，可以很轻松的调用相关方法来完成业务消息的序列化与反序列化工作。</li></ul><h2 id="2-创建framework"><a href="#2-创建framework" class="headerlink" title="2 创建framework"></a>2 创建framework</h2><h3 id="2-1-生成framework"><a href="#2-1-生成framework" class="headerlink" title="2.1 生成framework"></a>2.1 生成framework</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 下载 mars 仓库: </span><br><span class="line">git clone https://github.com/Tencent/mars.git</span><br><span class="line">// 切换到 libraries路径</span><br><span class="line">cd mars-master/mars/libraries</span><br><span class="line">// 执行python脚本</span><br><span class="line">python build_apple.py</span><br><span class="line">提示输入保存文件夹的前缀:(随意)</span><br><span class="line">input prefix for save directory. like trunk,br,tag:</span><br><span class="line">选择build的类型: 1代表iphone版mars(其中包括xlog)</span><br><span class="line">Enter menu:</span><br><span class="line">build mars for iphone.</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2017/12/7/1602f5e5c25aeef5?w=680&h=415&f=png&s=309178" alt="success..."></p><h3 id="2-2-引入framework"><a href="#2-2-引入framework" class="headerlink" title="2.2 引入framework"></a>2.2 引入framework</h3><p>// log_crypt.cc.rewriteme, log_crypt.h 这两个文件已被废弃,可直接删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 删除.rewriteme的后缀</span><br><span class="line">共三个文件log_crypt.cc.rewriteme(废弃),longlink_packer.cc.rewriteme, shortlink_packer.cc.rewriteme</span><br><span class="line">// 拖入工程,并添加库</span><br><span class="line">SystemConfiguration, CoreTelephony, Foundation, libz.tbd, libresolv9.tbd</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2017/12/7/1602f5e5c27f08fa?w=701&h=217&f=png&s=34907" alt></p><h3 id="2-3-xlog"><a href="#2-3-xlog" class="headerlink" title="2.3 xlog"></a>2.3 xlog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/// 添加文件(demo中有)</span><br><span class="line">LogHelper.h(.mm)、LogUtil.h(.mm), appender-swift-bridge.h(.mm)</span><br><span class="line">/// 桥接头文件添加</span><br><span class="line">#import &quot;appender-swift-bridge.h&quot;</span><br><span class="line"></span><br><span class="line">// 配置xlog, 参数分别代表:debug时记录的级别,release时记录的级别,保存文件的相对路径,文件前缀</span><br><span class="line">JinkeyMarsBridge().initXlogger(...)</span><br><span class="line">// 自定义log</span><br><span class="line">JinkeyMarsBridge().log(...)</span><br></pre></td></tr></table></figure><p>在didFinishLaunchingWithOptions配置xlog<br>在applicationWillTerminate中destory</p><h3 id="2-4-引入protobuf"><a href="#2-4-引入protobuf" class="headerlink" title="2.4 引入protobuf"></a>2.4 引入protobuf</h3><h4 id="2-4-1-生成-pb-swift"><a href="#2-4-1-生成-pb-swift" class="headerlink" title="2.4.1 生成.pb.swift"></a>2.4.1 生成.pb.swift</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 安装protobuf</span><br><span class="line">brew install protobuf</span><br><span class="line">// 安装swift-protobuf-plugin</span><br><span class="line">git clone https://github.com/apple/swift-protobuf.git</span><br><span class="line">cd swift-protobuf</span><br><span class="line">swift build -c release -Xswiftc -static-stdlib</span><br><span class="line"></span><br><span class="line">// 将.proto文件转换成.swift</span><br><span class="line">protoc --swift_out=. name.proto</span><br></pre></td></tr></table></figure><p>写了个shell,可以批量将当前文件夹下的所有.proto转换成对应的.pb.swift<br>地址为<a href="https://github.com/515783034/FileResource/blob/master/swift-join-mars/proto/install.sh" target="_blank" rel="noopener">install.sh</a>,可直接双击使用<br>内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd $(cd `dirname $0`; pwd)</span><br><span class="line"></span><br><span class="line">for i in find *.proto</span><br><span class="line">do</span><br><span class="line">    if [ $i == "find" ]; then</span><br><span class="line">        continue</span><br><span class="line">    fi</span><br><span class="line">    protoc --swift_out=. $i</span><br><span class="line">    echo "生成文件:$i.pb.swift"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="2-4-2-引入-pb-swift"><a href="#2-4-2-引入-pb-swift" class="headerlink" title="2.4.2 引入.pb.swift"></a>2.4.2 引入.pb.swift</h4><p><a href="https://github.com/apple/swift-protobuf" target="_blank" rel="noopener">swift-protobuf</a>: Plugin and runtime library for using protobuf with Swift</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// pod引用</span><br><span class="line">pod &apos;SwiftProtobuf&apos;</span><br><span class="line">// 将.pb.swift添加到工程中(不用添加.proto)</span><br><span class="line">// 使用</span><br><span class="line">var con = Conversation()</span><br><span class="line">con.name = &quot;ashen&quot;</span><br><span class="line">con.notice = &quot;for test&quot;</span><br><span class="line">// 传输时,直接传递data数据</span><br><span class="line">let data = try? con.serializedData()</span><br></pre></td></tr></table></figure><h3 id="2-5-添加桥接文件-可选"><a href="#2-5-添加桥接文件-可选" class="headerlink" title="2.5 添加桥接文件(可选)"></a>2.5 添加桥接文件(可选)</h3><p>由于该framework是C++写的,对于不会C++的人(比如我)来说, 调用是个很大的问题, 可以通过demo中的相关文件 + swift-oc桥接头文件直接转换成swift可以直接调用的类<br><img src="https://user-gold-cdn.xitu.io/2017/12/7/1602f5e5c21b74ee?w=614&h=325&f=png&s=295127" alt="相关文件"></p><h2 id="3-xlog文件解析"><a href="#3-xlog文件解析" class="headerlink" title="3 xlog文件解析"></a>3 xlog文件解析</h2><h3 id="3-1-安装python依赖库"><a href="#3-1-安装python依赖库" class="headerlink" title="3.1 安装python依赖库."></a>3.1 安装python依赖库.</h3><p><strong>首先需要查看自己的python版本, decode_mars_crypt_log_file.py只在python2.+下支持,3.+不能正常运行</strong></p><p>安装依赖库pyelliptic, 如果同时存在2.+ 和3.+ 版本,请使用pip2<br>pyelliptic的最新版本1.5.8,存在bug, 需要指定版本为1.5.7</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyelliptic==1.5.7</span><br></pre></td></tr></table></figure><h3 id="3-2-解密logger日志"><a href="#3-2-解密logger日志" class="headerlink" title="3.2 解密logger日志"></a>3.2 解密logger日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 切换到crypt文件夹</span><br><span class="line">cd mars/mars/log/crypt</span><br><span class="line">// 解密logger</span><br><span class="line">python2 decode_mars_crypt_log_file.py logger_20171205.xlog</span><br><span class="line">// logger_20171205.xlog.log 即为解密出的log日志</span><br></pre></td></tr></table></figure><hr><h2 id="fix-bugs"><a href="#fix-bugs" class="headerlink" title="fix bugs:"></a>fix bugs:</h2><ul><li><p>ImportError: No module named pyelliptic</p><p>原因:没有正确安装pyelliptic的依赖库</p><p>解决:  pip2 install pyelliptic==1.5.7</p><p>如果安装后依然报错,可能是由于安装了多个版本的python,pyelliptic并没有安装在2.+的python下.<br>在MacOS上, 如果同时安装了2.+ 和3.+的python,  pip2 和pip3 分别代表安装到2.+ 和3.+的库中. 所以可以通过pip2 install pyelliptic==1.5.7 安装</p></li></ul><ul><li>AttributeError: dlsym(0x7fc443f02f50, EVP_CIPHER_CTX_reset): symbol not found<br>原因: pyelliptic的最新版本1.5.8的bug<br>解决: 使用1.5.7版本<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip uninstall pyelliptic</span><br><span class="line">pip install pyelliptic==1.5.7</span><br></pre></td></tr></table></figure></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li><a href="https://github.com/515783034/FileResource/tree/master/swift-join-mars" target="_blank" rel="noopener">示例代码</a></li><li><a href="https://github.com/515783034/FileResource/blob/master/swift-join-mars/proto/install.sh" target="_blank" rel="noopener">批量转proto</a></li></ul><p>参考: <a href="http://www.jianshu.com/p/fe8c5f3f6389" target="_blank" rel="noopener">Swift 接入微信 Mars_Xlogger 填坑指南——Jinkey 原创</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> scrapy </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我用Xcode +python写的第一个OS X app</title>
      <link href="/2017/11/09/%E6%88%91%E7%94%A8Xcode%20+python%E5%86%99%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAOS%20X%20app/"/>
      <url>/2017/11/09/%E6%88%91%E7%94%A8Xcode%20+python%E5%86%99%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAOS%20X%20app/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2017/11/8/e1b5b80d8663bb50abf5ba6be27278f9?w=1240&h=698&f=jpeg&s=90584" alt></p><blockquote><p>前两天刚订阅了<a href="http://www.jianshu.com/u/3e55748920d2" target="_blank" rel="noopener">bestswifter</a>大大的小专栏，其中《2018 年将至，ios 工程师如何自我提高》这篇文章使我感触颇深，最近刚好开始看python, 就萌生了写一个python脚本练练手的想法。</p></blockquote><h2 id="1-为什么要写这个app？"><a href="#1-为什么要写这个app？" class="headerlink" title="1. 为什么要写这个app？"></a>1. 为什么要写这个app？</h2><p>  原因之一当然是学了点东西总想练练手。<br>  更为重要的原因则是，在写iOS app时，每增加一个网络请求，就要写一个json对应的model类，而构造这些model类的代码毫无快感可言。so，人生苦短，我用python</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2017/11/8/200e8982e2fdd2e1c33df6ef9c818595?w=1031&h=505&f=gif&s=379843" alt></p><hr><h2 id="2-技术栈"><a href="#2-技术栈" class="headerlink" title="2. 技术栈"></a>2. 技术栈</h2><h3 id="python最最最基础知识"><a href="#python最最最基础知识" class="headerlink" title="python最最最基础知识"></a>python最最最基础知识</h3><h4 id="1-json反序列化"><a href="#1-json反序列化" class="headerlink" title="1. json反序列化"></a>1. json反序列化</h4><p>将输入的json字符串转成对应的字典(dict) + 数组(list)组合的形式<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = json.loads(&quot;输入的json字符串&quot;)</span><br></pre></td></tr></table></figure></p><h4 id="2-字符串操作"><a href="#2-字符串操作" class="headerlink" title="2. 字符串操作"></a>2. 字符串操作</h4><p>  解析字典和数组内容，生成swift对应的字符串，拼接起来即可<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 遍历字典</span><br><span class="line">for (key, value) in dic.items():</span><br><span class="line"></span><br><span class="line"># 转换成swift格式</span><br><span class="line">if isinstance(value, str):</span><br><span class="line">    return &quot;String&quot;</span><br><span class="line">elif isinstance(value, float):</span><br><span class="line">    return &quot;Float&quot;</span><br><span class="line"></span><br><span class="line"># 字符串数组拼接</span><br><span class="line">result= &apos;&apos;.join([line+&apos;\n&apos; for line in res])</span><br></pre></td></tr></table></figure></p><p>  推荐两个不错学习资源：<a href="http://www.jianshu.com/p/8ec836ddef5e" target="_blank" rel="noopener">Python 简单入门指北（试读）</a>，<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">Python教程- 廖雪峰</a></p><h3 id="Cocoa-APP生成"><a href="#Cocoa-APP生成" class="headerlink" title="Cocoa APP生成"></a>Cocoa APP生成</h3><h4 id="1-界面搭建"><a href="#1-界面搭建" class="headerlink" title="1. 界面搭建"></a>1. 界面搭建</h4><p>Mac OS的界面搭建和iOS超级相似，如果会iOS编程，3分钟就能搞定，这里不做赘述。</p><blockquote><p><img src="https://user-gold-cdn.xitu.io/2017/11/8/b188c6190dd0acf63cf50f5a3c20a7dc?w=1033&h=528&f=png&s=15593" alt></p></blockquote><h4 id="2-图标生成"><a href="#2-图标生成" class="headerlink" title="2. 图标生成"></a>2. 图标生成</h4><p>制作一个1024*1024的图片，我习惯使用<a href="http://www.pixelmator.com/mac/" target="_blank" rel="noopener">pixelmator</a>，个人感觉比较简单上手，然后生成若干张对应尺寸的图标，这种app有很多，我用的是<a href="https://itunes.apple.com/cn/app/id476533227?mt=12" target="_blank" rel="noopener">Prepo</a></p><blockquote><p><img src="https://user-gold-cdn.xitu.io/2017/11/8/95cbe825eb9a297aed97bc2b5f1a4402?w=895&h=283&f=png&s=67311" alt></p></blockquote><h4 id="3-Cocoa-运行python脚本"><a href="#3-Cocoa-运行python脚本" class="headerlink" title="3. Cocoa 运行python脚本"></a>3. Cocoa 运行python脚本</h4><p>NSTask已经被废弃，应该使用Process()执行脚本文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let buildTask = Process()</span><br><span class="line">let outPip = Pipe()</span><br><span class="line">let errorPipe = Pipe()</span><br><span class="line"></span><br><span class="line">buildTask.launchPath = &quot;/usr/bin/python&quot;</span><br><span class="line">// arguments是[String]类型，第一个元素应该为xx.py的路径，后面元素为该py接受的参数</span><br><span class="line">buildTask.arguments = args</span><br><span class="line">buildTask.standardInput = Pipe()</span><br><span class="line">buildTask.standardOutput = outPip</span><br><span class="line">buildTask.standardError = errorPipe</span><br><span class="line">// 脚本执行完毕后的回调</span><br><span class="line">buildTask.terminationHandler = &#123; p in</span><br><span class="line">      self.taskFinish()</span><br><span class="line">&#125;</span><br><span class="line">buildTask.launch()</span><br><span class="line">buildTask.waitUntilExit()</span><br><span class="line"></span><br><span class="line">// 脚本的输出结果，即脚本文件的print()方法打印的内容</span><br><span class="line">let data = outPip.fileHandleForReading.readDataToEndOfFile()</span><br><span class="line">let output = String(data: data, encoding: String.Encoding.utf8)</span><br><span class="line">        </span><br><span class="line">// 错误处理, python系统错误</span><br><span class="line">let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()</span><br><span class="line">let errorStr = String(data: errorData, encoding: String.Encoding.utf8)</span><br><span class="line">if let aError = errorStr, aError != &quot;&quot; &#123;</span><br><span class="line">    sendError(&quot;解析错误\r\n&quot; + aError)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>arguments：脚本参数</p><blockquote><p>let scripyPath = Bundle.main.path(forResource: “Parse”, ofType: “py”)! // 脚本路径<br>let para1 = “input info” // 传入参数，通过sys.argv[I]获取<br>let args = [scripyPath, para1]<br>buildTask.arguments = args</p></blockquote></li><li><p>standardOutput：脚本输出</p><blockquote><p>执行脚本后可通过output获取结果<br>注意：脚本的返回结果不是通过函数的return，而是通过调用print(infos)函数，即infos作为结果返回<br>let data = outPip.fileHandleForReading.readDataToEndOfFile()<br>let output = String(data: data, encoding: String.Encoding.utf8)</p></blockquote></li><li><p>standardError: 错误输出</p><blockquote><p>解决python的exception信息<br>task.terminationStatus 不等于0也能判断为失败</p></blockquote></li></ul><hr><h2 id="3-封装"><a href="#3-封装" class="headerlink" title="3. 封装"></a>3. 封装</h2><p>  Cocoa 运行python脚本的代码，写起来虽然不算特别麻烦，但总也说不是简洁，于是重新封装了一个类方便调用：<a href="https://github.com/515783034/json2swift/blob/master/json2Swift/CocoaPython.swift" target="_blank" rel="noopener">CocoaPython</a><br>使用如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="type">CocoaPython</span>(scrPath: pyPath)</span><br><span class="line">script.runAsync()</span><br></pre></td></tr></table></figure><p>详细说明：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// python脚本文件路径</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> aPath = <span class="type">Bundle</span>.main.path(forResource: <span class="string">"Parse"</span>, ofType: <span class="string">"py"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// args: py文件接受的参数列表，通过sys.argv[i]访问</span></span><br><span class="line"><span class="comment">// block: 完成后的回调，包括返回值和错误内容</span></span><br><span class="line"><span class="keyword">let</span> script = <span class="type">CocoaPython</span>(scrPath: aPath, args: [<span class="string">""</span>]) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>($<span class="number">0</span>) <span class="comment">// 返回值，所有的py中print()的内容</span></span><br><span class="line">    <span class="built_in">print</span>($<span class="number">1</span>) <span class="comment">// py中的错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">script.spliPara = <span class="string">"$"</span> <span class="comment">// 如果有多个结果，每个结果之间的分隔符，不设置则将所有的结果当成一个结果返回，即result == result[0]</span></span><br><span class="line">script.runAsync() <span class="comment">// 异步执行，回调在异步主线程中调用</span></span><br><span class="line"><span class="comment">// or script.runAsync(asyncComlete: false) // 异步执行，回调在global中执行</span></span><br><span class="line"><span class="comment">// or script.runSync() // 同步执行</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-资源"><a href="#4-资源" class="headerlink" title="4. 资源"></a>4. 资源</h2><p>github地址:  <a href="https://github.com/515783034/json2swift" target="_blank" rel="noopener">json2swift</a><br>OS X app:  <a href="https://pan.baidu.com/s/1skW4Jxj" target="_blank" rel="noopener">json2Swift.app</a><br>python 脚本:  <a href="https://pan.baidu.com/s/1kV1jhbh" target="_blank" rel="noopener">json2Swift.py</a></p>]]></content>
      
      
      <categories>
          
          <category> macos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macos </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
